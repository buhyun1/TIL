
def get_maze_answer(maze : dict, end_point = (1,1)) -> list:
    """ 미로에 대한 정보를 dict 타입으로 입력 받아서 해당 미로의 답을 반환한다.
    Args:
        maze (dict) : 미로에 대한 정보를 포함하고 있으며, 해당 정보는 위치 정보와 이동 가능한 방향에 대한 정보를 포함한다.
    Example:
        maze = {(1, 1): {'E': 0, 'W': 0, 'N': 0, 'S': 1},
                (2, 1): {'E': 1, 'W': 0, 'N': 1, 'S': 0},
                (3, 1): {'E': 1, 'W': 0, 'N': 0, 'S': 0},
                (1, 2): {'E': 1, 'W': 0, 'N': 0, 'S': 0},
                (2, 2): {'E': 0, 'W': 1, 'N': 0, 'S': 1},
                (3, 2): {'E': 1, 'W': 1, 'N': 1, 'S': 0},
                (1, 3): {'E': 0, 'W': 1, 'N': 0, 'S': 1},
                (2, 3): {'E': 0, 'W': 0, 'N': 1, 'S': 1},
                (3, 3): {'E': 0, 'W': 1, 'N': 1, 'S': 0}}
    Returns:
        maze_solution (list) : `maze` 데이터를 바탕으로 최적의 이동 솔루션을 list 타입으로 출력한다.
                                list의 값은 공간 위치에 대한 정보를 포함한다.
    Example:
        >>> solution = get_maze_answer(maze)
        >>> solution
            [(3, 3), (3, 2), (2, 2), (2, 1), (1, 1)]
    """
    
    start = list(maze)[-1] # maze 리스트의 (n,m) 시작
    peek = start
    visited = [start]

    while len(visited) > 0: # 방문 길이가 0보다 작아질 때 까지 실행
        
        if  maze.get(peek)['E'] == 1: #동쪽일 때, 지나온 길 막아주고, 한칸 이동 
            maze.get(peek)['E'] = 2
            peek = (peek[0], peek[1]+1)
            visited.append(peek)
            maze.get(peek)['W'] = 2
        
        elif maze.get(peek)['W'] == 1: #서쪽일 때, 지나온 길 막아주고, 한칸 이동 
            maze.get(peek)['W'] = 2
            peek = (peek[0], peek[1]-1)
            visited.append(peek)
            maze.get(peek)['E'] = 2
        
        elif maze.get(peek)['N'] == 1: #북쪽일 때, 지나온 길 막아주고, 한칸 이동 
            maze.get(peek)['N'] = 2
            peek = (peek[0]-1, peek[1])
            visited.append(peek)
            maze.get(peek)['S'] = 2

        elif maze.get(peek)['S'] == 1: #남쪽일 때, 지나온 길 막아주고, 한칸 이동 
            maze.get(peek)['S'] = 2
            peek = (peek[0]+1, peek[1])
            visited.append(peek)
            maze.get(peek)['N'] = 2

        elif peek == end_point: # 끝 지점에 도달하면 지나온 경로 추가, 다시 뒤로 돌아감
            way = []
            plus_way(way, visited)
            peek = visited[-2]

        else: # 막혀 있다면 끝까지 뒤로 pop으로 뽑아주기
            visited.pop() 
            if len(visited) > 0:
                peek = visited[len(visited)-1]

    way.sort(key=lambda x: len(x)) # 최단 경로를 찾아주기 위한 sort

    return way[0]

def plus_way(way, path): # 지나온 경로 모두 추가 해주는 함수
    visit = []
    for i in path:
        visit.append(i)
    way.append(visit)
    return way

# maze = {(1, 1): {'E': 1, 'W': 0, 'N': 0, 'S': 0}, (2, 1): {'E': 0, 'W': 0, 'N': 0, 'S': 1}, (3, 1): {'E': 0, 'W': 0, 'N': 1, 'S': 1}, (4, 1): {'E': 0, 'W': 0, 'N': 1, 'S': 1},
#                 (5, 1): {'E': 1, 'W': 0, 'N': 1, 'S': 0}, (1, 2): {'E': 0, 'W': 1, 'N': 0, 'S': 1}, (2, 2): {'E': 1, 'W': 0, 'N': 1, 'S': 0}, (3, 2): {'E': 1, 'W': 0, 'N': 0, 'S': 1}, (4, 2): {'E': 1, 'W': 0, 'N': 1, 'S': 0},
#                 (5, 2): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (1, 3): {'E': 1, 'W': 0, 'N': 0, 'S': 0}, (2, 3): {'E': 1, 'W': 1, 'N': 0, 'S': 0},
#                 (3, 3): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (4, 3): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (5, 3): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (1, 4): {'E': 1, 'W': 1, 'N': 0, 'S': 0},
#                 (2, 4): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (3, 4): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (4, 4): {'E': 0, 'W': 1, 'N': 0, 'S': 1}, (5, 4): {'E': 1, 'W': 1, 'N': 1, 'S': 0}, (1, 5): {'E': 0, 'W': 1, 'N': 0, 'S': 1}, (2, 5): {'E': 0, 'W': 1, 'N': 1, 'S': 1}, (3, 5): {'E': 0, 'W': 1, 'N': 1, 'S': 0},
#                 (4, 5): {'E': 0, 'W': 0, 'N': 0, 'S': 1}, (5, 5): {'E': 0, 'W': 1, 'N': 1, 'S': 0}}
# solution = [(5, 5),  (5, 4), (4, 4), (4, 3), (4, 2), (3, 2), (3, 3), (3, 4), (3, 5), (2, 5), (2, 4), (2, 3), (2, 2), (1, 2), (1, 1)]

        
# maze = {(1, 1): {'E': 1, 'W': 0, 'N': 0, 'S': 0}, (2, 1): {'E': 0, 'W': 0, 'N': 0, 'S': 1}, (3, 1): {'E': 0, 'W': 0, 'N': 1, 'S': 1}, (4, 1): {'E': 0, 'W': 0, 'N': 1, 'S': 1},
#                 (5, 1): {'E': 1, 'W': 0, 'N': 1, 'S': 0}, (1, 2): {'E': 0, 'W': 1, 'N': 0, 'S': 1}, (2, 2): {'E': 1, 'W': 0, 'N': 1, 'S': 0}, (3, 2): {'E': 1, 'W': 0, 'N': 0, 'S': 1}, (4, 2): {'E': 1, 'W': 0, 'N': 1, 'S': 0},
#                 (5, 2): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (1, 3): {'E': 1, 'W': 0, 'N': 0, 'S': 0}, (2, 3): {'E': 1, 'W': 1, 'N': 0, 'S': 0},
#                 (3, 3): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (4, 3): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (5, 3): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (1, 4): {'E': 1, 'W': 1, 'N': 0, 'S': 0},
#                 (2, 4): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (3, 4): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (4, 4): {'E': 0, 'W': 1, 'N': 0, 'S': 1}, (5, 4): {'E': 1, 'W': 1, 'N': 1, 'S': 0}, (1, 5): {'E': 0, 'W': 1, 'N': 0, 'S': 1}, (2, 5): {'E': 0, 'W': 1, 'N': 1, 'S': 1}, (3, 5): {'E': 0, 'W': 1, 'N': 1, 'S': 0},
#                 (4, 5): {'E': 0, 'W': 0, 'N': 0, 'S': 1}, (5, 5): {'E': 0, 'W': 1, 'N': 1, 'S': 0}}
# solution = [(5, 5),  (5, 4), (4, 4), (4, 3), (4, 2), (3, 2), (3, 3), (3, 4), (3, 5), (2, 5), (2, 4), (2, 3), (2, 2), (1, 2), (1, 1)]

# maze = {(1, 1): {'E': 0, 'W': 0, 'N': 0, 'S': 1},
#                 (2, 1): {'E': 1, 'W': 0, 'N': 1, 'S': 0},
#                 (3, 1): {'E': 1, 'W': 0, 'N': 0, 'S': 0},
#                 (1, 2): {'E': 1, 'W': 0, 'N': 0, 'S': 0},
#                 (2, 2): {'E': 0, 'W': 1, 'N': 0, 'S': 1},
#                 (3, 2): {'E': 1, 'W': 1, 'N': 1, 'S': 0},
#                 (1, 3): {'E': 0, 'W': 1, 'N': 0, 'S': 1},
#                 (2, 3): {'E': 0, 'W': 0, 'N': 1, 'S': 1},
#                 (3, 3): {'E': 0, 'W': 1, 'N': 1, 'S': 0}}
# solution = [(3, 3), (3, 2), (2, 2), (2, 1), (1, 1)]

# print(get_maze_answer(maze))